'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = void 0;

function _chalk() {
  const data = _interopRequireDefault(require('chalk'));

  _chalk = function() {
    return data;
  };

  return data;
}

var _logger = _interopRequireDefault(require('../util/logger'));

var _pollParams = _interopRequireDefault(require('./pollParams'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const linkDependency = async (platforms, project, dependency) => {
  const params = await (0, _pollParams.default)(dependency.params);
  Object.keys(platforms || {}).forEach(platform => {
    if (!project[platform] || !dependency.config[platform]) {
      return;
    }

    const linkConfig =
      platforms[platform] &&
      platforms[platform].linkConfig &&
      platforms[platform].linkConfig();

    if (!linkConfig || !linkConfig.isInstalled || !linkConfig.register) {
      return;
    }

    const isInstalled = linkConfig.isInstalled(
      project[platform],
      dependency.name,
      dependency.config[platform]
    );

    if (isInstalled) {
      _logger.default.info(
        _chalk().default.grey(
          `Platform '${platform}' module ${dependency.name} is already linked`
        )
      );

      return;
    }

    _logger.default.info(`Linking ${dependency.name} ${platform} dependency`);

    linkConfig.register(
      dependency.name, // $FlowFixMe: We check if dependency.config[platform] exists on line 42
      dependency.config[platform],
      params, // $FlowFixMe: We check if project[platform] exists on line 42
      project[platform]
    );

    _logger.default.info(
      `Platform '${platform}' module ${
        dependency.name
      } has been successfully linked`
    );
  });
};

var _default = linkDependency;
exports.default = _default;
