'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = void 0;

function _chalk() {
  const data = _interopRequireDefault(require('chalk'));

  _chalk = function() {
    return data;
  };

  return data;
}

function _child_process() {
  const data = _interopRequireDefault(require('child_process'));

  _child_process = function() {
    return data;
  };

  return data;
}

function _commander() {
  const data = _interopRequireDefault(require('commander'));

  _commander = function() {
    return data;
  };

  return data;
}

function _minimist() {
  const data = _interopRequireDefault(require('minimist'));

  _minimist = function() {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require('path'));

  _path = function() {
    return data;
  };

  return data;
}

var _getCommands = _interopRequireDefault(require('./core/getCommands'));

var _getLegacyConfig = _interopRequireDefault(
  require('./core/getLegacyConfig')
);

var _init = _interopRequireDefault(require('./init/init'));

var _assertRequiredOptions = _interopRequireDefault(
  require('./util/assertRequiredOptions')
);

var _logger = _interopRequireDefault(require('./util/logger'));

var _package = _interopRequireDefault(require('../package.json'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(
        Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        })
      );
    }
    ownKeys.forEach(function(key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

_commander()
  .default.version(_package.default.version)
  .option('--projectRoot [string]', 'Path to the root of the project')
  .option('--reactNativePath [string]', 'Path to React Native');

_commander().default.on('command:*', () => {
  printUnknownCommand(_commander().default.args.join(' '));
  process.exit(1);
});

const defaultOptParser = val => val;

const handleError = err => {
  _logger.default.error(err.message);

  process.exit(1);
}; // Custom printHelpInformation command inspired by internal Commander.js
// one modified to suit our needs

function printHelpInformation() {
  let cmdName = this._name;

  if (this._alias) {
    cmdName = `${cmdName}|${this._alias}`;
  }

  const sourceInformation = this.pkg
    ? [
        `  ${_chalk().default.bold('Source:')} ${this.pkg.name}@${
          this.pkg.version
        }`,
        ''
      ]
    : [];
  let output = [
    '',
    _chalk().default.bold(
      _chalk().default.cyan(`  react-native ${cmdName} ${this.usage()}`)
    ),
    this._description ? `  ${this._description}` : '',
    '',
    ...sourceInformation,
    `  ${_chalk().default.bold('Options:')}`,
    '',
    this.optionHelp().replace(/^/gm, '    '),
    ''
  ];

  if (this.examples && this.examples.length > 0) {
    const formattedUsage = this.examples
      .map(
        example =>
          `    ${example.desc}: \n    ${_chalk().default.cyan(example.cmd)}`
      )
      .join('\n\n');
    output = output.concat([
      _chalk().default.bold('  Example usage:'),
      '',
      formattedUsage
    ]);
  }

  return output.concat(['', '']).join('\n');
}

function printUnknownCommand(cmdName) {
  if (cmdName) {
    _logger.default.error(
      `Unrecognized command "${_chalk().default.bold(cmdName)}".`
    );

    _logger.default.info(
      `Run ${_chalk().default.bold(
        '"react-native --help"'
      )} to see a list of all available commands.`
    );
  } else {
    _commander().default.outputHelp();
  }
}

const addCommand = (command, ctx) => {
  const options = command.options || [];

  const cmd = _commander()
    .default.command(command.name, undefined, {
      noHelp: !command.description
    })
    .description(command.description)
    .action(function handleAction(...args) {
      const passedOptions = this.opts();
      const argv = Array.from(args).slice(0, -1);
      Promise.resolve()
        .then(() => {
          (0, _assertRequiredOptions.default)(options, passedOptions);
          return command.func(argv, ctx, passedOptions);
        })
        .catch(handleError);
    });

  cmd.helpInformation = printHelpInformation.bind(cmd);
  cmd.examples = command.examples; // $FlowFixMe: This is either null or not

  cmd.pkg = command.pkg;
  options.forEach(opt =>
    cmd.option(
      opt.command,
      opt.description,
      opt.parse || defaultOptParser,
      typeof opt.default === 'function' ? opt.default(ctx) : opt.default
    )
  ); // Redefined here to appear in the `--help` section

  cmd
    .option('--projectRoot [string]', 'Path to the root of the project')
    .option('--reactNativePath [string]', 'Path to React Native');
};

async function run() {
  try {
    await setupAndRun();
  } catch (e) {
    handleError(e);
  }
}

async function setupAndRun() {
  const setupEnvScript = /^win/.test(process.platform)
    ? _path().default.join('..', 'setup_env.bat')
    : _path().default.join('..', 'setup_env.sh');

  _child_process().default.execFileSync(
    _path().default.join(__dirname, setupEnvScript)
  );
  /**
   * Read passed `options` and take the "global" settings
   *
   * @todo(grabbou): Consider unifying this by removing either `commander`
   * or `minimist`
   */

  const options = (0, _minimist().default)(process.argv.slice(2));
  const root = options.projectRoot
    ? _path().default.resolve(options.projectRoot)
    : process.cwd();
  const reactNativePath = options.reactNativePath
    ? _path().default.resolve(options.reactNativePath)
    : (() => {
        try {
          return _path().default.dirname(
            // $FlowIssue: Wrong `require.resolve` type definition
            require.resolve('react-native/package.json', {
              paths: [root]
            })
          );
        } catch (_ignored) {
          throw new Error(
            'Unable to find React Native files. Make sure "react-native" module is installed in your project dependencies.'
          );
        }
      })();

  const ctx = _objectSpread({}, (0, _getLegacyConfig.default)(root), {
    reactNativePath,
    root
  });

  const commands = (0, _getCommands.default)(ctx.root);
  commands.forEach(command => addCommand(command, ctx));

  _commander().default.parse(process.argv);

  if (!options._.length) {
    _commander().default.outputHelp();
  }
}

var _default = {
  run,
  init: _init.default
}; // export { run, init };

exports.default = _default;
